/// Generated by ForEachGenerator.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.Entities
{
    public partial class ComponentSystem
    {
         
        protected delegate void F_ED<T0>(Entity entity, ref T0 c0)            where T0 : struct, IComponentData;

        unsafe protected void ForEach<T0>(F_ED<T0> operate, ComponentGroup group = null) where T0 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_D<T0>(ref T0 c0)            where T0 : struct, IComponentData;

        unsafe protected void ForEach<T0>(F_D<T0> operate, ComponentGroup group = null) where T0 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EC<T0>(Entity entity, T0 c0)            where T0 : class;

        unsafe protected void ForEach<T0>(F_EC<T0> operate, ComponentGroup group = null) where T0 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_C<T0>(T0 c0)            where T0 : class;

        unsafe protected void ForEach<T0>(F_C<T0> operate, ComponentGroup group = null) where T0 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EB<T0>(Entity entity, DynamicBuffer<T0> c0)            where T0 : struct, IBufferElementData;

        unsafe protected void ForEach<T0>(F_EB<T0> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_B<T0>(DynamicBuffer<T0> c0)            where T0 : struct, IBufferElementData;

        unsafe protected void ForEach<T0>(F_B<T0> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ES<T0>(Entity entity, T0 c0)            where T0 : struct, ISharedComponentData;

        unsafe protected void ForEach<T0>(F_ES<T0> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_S<T0>(T0 c0)            where T0 : struct, ISharedComponentData;

        unsafe protected void ForEach<T0>(F_S<T0> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDD<T0, T1>(Entity entity, ref T0 c0, ref T1 c1)            where T0 : struct, IComponentData where T1 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1>(F_EDD<T0, T1> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DD<T0, T1>(ref T0 c0, ref T1 c1)            where T0 : struct, IComponentData where T1 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1>(F_DD<T0, T1> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDDD<T0, T1, T2>(Entity entity, ref T0 c0, ref T1 c1, ref T2 c2)            where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2>(F_EDDD<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DDD<T0, T1, T2>(ref T0 c0, ref T1 c1, ref T2 c2)            where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2>(F_DDD<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDDDD<T0, T1, T2, T3>(Entity entity, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)            where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_EDDDD<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DDDD<T0, T1, T2, T3>(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)            where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_DDDD<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDDDDD<T0, T1, T2, T3, T4>(Entity entity, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)            where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_EDDDDD<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DDDDD<T0, T1, T2, T3, T4>(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)            where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_DDDDD<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)            where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_EDDDDDD<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DDDDDD<T0, T1, T2, T3, T4, T5>(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)            where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_DDDDDD<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECD<T0, T1>(Entity entity, T0 c0, ref T1 c1)            where T0 : class where T1 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1>(F_ECD<T0, T1> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CD<T0, T1>(T0 c0, ref T1 c1)            where T0 : class where T1 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1>(F_CD<T0, T1> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECDD<T0, T1, T2>(Entity entity, T0 c0, ref T1 c1, ref T2 c2)            where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2>(F_ECDD<T0, T1, T2> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CDD<T0, T1, T2>(T0 c0, ref T1 c1, ref T2 c2)            where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2>(F_CDD<T0, T1, T2> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECDDD<T0, T1, T2, T3>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)            where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_ECDDD<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CDDD<T0, T1, T2, T3>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)            where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_CDDD<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECDDDD<T0, T1, T2, T3, T4>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)            where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_ECDDDD<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CDDDD<T0, T1, T2, T3, T4>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)            where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_CDDDD<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)            where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_ECDDDDD<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CDDDDD<T0, T1, T2, T3, T4, T5>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)            where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_CDDDDD<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : class where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBD<T0, T1>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1>(F_EBD<T0, T1> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BD<T0, T1>(DynamicBuffer<T0> c0, ref T1 c1)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1>(F_BD<T0, T1> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBDD<T0, T1, T2>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2>(F_EBDD<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BDD<T0, T1, T2>(DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2>(F_BDD<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBDDD<T0, T1, T2, T3>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_EBDDD<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BDDD<T0, T1, T2, T3>(DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_BDDD<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBDDDD<T0, T1, T2, T3, T4>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_EBDDDD<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BDDDD<T0, T1, T2, T3, T4>(DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_BDDDD<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_EBDDDDD<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BDDDDD<T0, T1, T2, T3, T4, T5>(DynamicBuffer<T0> c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)            where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_BDDDDD<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESD<T0, T1>(Entity entity, T0 c0, ref T1 c1)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1>(F_ESD<T0, T1> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SD<T0, T1>(T0 c0, ref T1 c1)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1>(F_SD<T0, T1> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESDD<T0, T1, T2>(Entity entity, T0 c0, ref T1 c1, ref T2 c2)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2>(F_ESDD<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SDD<T0, T1, T2>(T0 c0, ref T1 c1, ref T2 c2)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2>(F_SDD<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESDDD<T0, T1, T2, T3>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_ESDDD<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SDDD<T0, T1, T2, T3>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_SDDD<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESDDDD<T0, T1, T2, T3, T4>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_ESDDDD<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SDDDD<T0, T1, T2, T3, T4>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_SDDDD<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESDDDDD<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_ESDDDDD<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SDDDDD<T0, T1, T2, T3, T4, T5>(T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5)            where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_SDDDDD<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : struct, IComponentData where T2 : struct, IComponentData where T3 : struct, IComponentData where T4 : struct, IComponentData where T5 : struct, IComponentData
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>(false);
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>(false);
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>(false);
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>(false);
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>(false);

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                        var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                        var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                        var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                        var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                        for (int i = 0; i < length; ++i)
                            operate(array0, ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i));
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDC<T0, T1>(Entity entity, ref T0 c0, T1 c1)            where T0 : struct, IComponentData where T1 : class;

        unsafe protected void ForEach<T0, T1>(F_EDC<T0, T1> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DC<T0, T1>(ref T0 c0, T1 c1)            where T0 : struct, IComponentData where T1 : class;

        unsafe protected void ForEach<T0, T1>(F_DC<T0, T1> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDCC<T0, T1, T2>(Entity entity, ref T0 c0, T1 c1, T2 c2)            where T0 : struct, IComponentData where T1 : class where T2 : class;

        unsafe protected void ForEach<T0, T1, T2>(F_EDCC<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class where T2 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DCC<T0, T1, T2>(ref T0 c0, T1 c1, T2 c2)            where T0 : struct, IComponentData where T1 : class where T2 : class;

        unsafe protected void ForEach<T0, T1, T2>(F_DCC<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class where T2 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDCCC<T0, T1, T2, T3>(Entity entity, ref T0 c0, T1 c1, T2 c2, T3 c3)            where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_EDCCC<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DCCC<T0, T1, T2, T3>(ref T0 c0, T1 c1, T2 c2, T3 c3)            where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_DCCC<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDCCCC<T0, T1, T2, T3, T4>(Entity entity, ref T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)            where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class where T4 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_EDCCCC<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class where T4 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DCCCC<T0, T1, T2, T3, T4>(ref T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)            where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class where T4 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_DCCCC<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class where T4 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EDCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, ref T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)            where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_EDCCCCC<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_DCCCCC<T0, T1, T2, T3, T4, T5>(ref T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)            where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_DCCCCC<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, IComponentData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i), array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECC<T0, T1>(Entity entity, T0 c0, T1 c1)            where T0 : class where T1 : class;

        unsafe protected void ForEach<T0, T1>(F_ECC<T0, T1> operate, ComponentGroup group = null) where T0 : class where T1 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CC<T0, T1>(T0 c0, T1 c1)            where T0 : class where T1 : class;

        unsafe protected void ForEach<T0, T1>(F_CC<T0, T1> operate, ComponentGroup group = null) where T0 : class where T1 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECCC<T0, T1, T2>(Entity entity, T0 c0, T1 c1, T2 c2)            where T0 : class where T1 : class where T2 : class;

        unsafe protected void ForEach<T0, T1, T2>(F_ECCC<T0, T1, T2> operate, ComponentGroup group = null) where T0 : class where T1 : class where T2 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i], array2[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CCC<T0, T1, T2>(T0 c0, T1 c1, T2 c2)            where T0 : class where T1 : class where T2 : class;

        unsafe protected void ForEach<T0, T1, T2>(F_CCC<T0, T1, T2> operate, ComponentGroup group = null) where T0 : class where T1 : class where T2 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i], array2[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECCCC<T0, T1, T2, T3>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3)            where T0 : class where T1 : class where T2 : class where T3 : class;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_ECCCC<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : class where T1 : class where T2 : class where T3 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CCCC<T0, T1, T2, T3>(T0 c0, T1 c1, T2 c2, T3 c3)            where T0 : class where T1 : class where T2 : class where T3 : class;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_CCCC<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : class where T1 : class where T2 : class where T3 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECCCCC<T0, T1, T2, T3, T4>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)            where T0 : class where T1 : class where T2 : class where T3 : class where T4 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_ECCCCC<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : class where T1 : class where T2 : class where T3 : class where T4 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CCCCC<T0, T1, T2, T3, T4>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)            where T0 : class where T1 : class where T2 : class where T3 : class where T4 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_CCCCC<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : class where T1 : class where T2 : class where T3 : class where T4 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ECCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)            where T0 : class where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_ECCCCCC<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : class where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_CCCCCC<T0, T1, T2, T3, T4, T5>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)            where T0 : class where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_CCCCCC<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : class where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
                var chunkComponentType0 = GetArchetypeChunkComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetComponentObjects(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBC<T0, T1>(Entity entity, DynamicBuffer<T0> c0, T1 c1)            where T0 : struct, IBufferElementData where T1 : class;

        unsafe protected void ForEach<T0, T1>(F_EBC<T0, T1> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BC<T0, T1>(DynamicBuffer<T0> c0, T1 c1)            where T0 : struct, IBufferElementData where T1 : class;

        unsafe protected void ForEach<T0, T1>(F_BC<T0, T1> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBCC<T0, T1, T2>(Entity entity, DynamicBuffer<T0> c0, T1 c1, T2 c2)            where T0 : struct, IBufferElementData where T1 : class where T2 : class;

        unsafe protected void ForEach<T0, T1, T2>(F_EBCC<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class where T2 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i], array2[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BCC<T0, T1, T2>(DynamicBuffer<T0> c0, T1 c1, T2 c2)            where T0 : struct, IBufferElementData where T1 : class where T2 : class;

        unsafe protected void ForEach<T0, T1, T2>(F_BCC<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class where T2 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i], array2[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBCCC<T0, T1, T2, T3>(Entity entity, DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3)            where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_EBCCC<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BCCC<T0, T1, T2, T3>(DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3)            where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_BCCC<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i], array2[i], array3[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBCCCC<T0, T1, T2, T3, T4>(Entity entity, DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3, T4 c4)            where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class where T4 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_EBCCCC<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class where T4 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BCCCC<T0, T1, T2, T3, T4>(DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3, T4 c4)            where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class where T4 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_BCCCC<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class where T4 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_EBCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)            where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_EBCCCCC<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_BCCCCC<T0, T1, T2, T3, T4, T5>(DynamicBuffer<T0> c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)            where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_BCCCCC<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, IBufferElementData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
                var chunkComponentType0 = GetArchetypeChunkBufferType<T0>(false);
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetBufferAccessor(chunkComponentType0);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0[i], array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESC<T0, T1>(Entity entity, T0 c0, T1 c1)            where T0 : struct, ISharedComponentData where T1 : class;

        unsafe protected void ForEach<T0, T1>(F_ESC<T0, T1> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, array1[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SC<T0, T1>(T0 c0, T1 c1)            where T0 : struct, ISharedComponentData where T1 : class;

        unsafe protected void ForEach<T0, T1>(F_SC<T0, T1> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0, array1[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESCC<T0, T1, T2>(Entity entity, T0 c0, T1 c1, T2 c2)            where T0 : struct, ISharedComponentData where T1 : class where T2 : class;

        unsafe protected void ForEach<T0, T1, T2>(F_ESCC<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class where T2 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, array1[i], array2[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SCC<T0, T1, T2>(T0 c0, T1 c1, T2 c2)            where T0 : struct, ISharedComponentData where T1 : class where T2 : class;

        unsafe protected void ForEach<T0, T1, T2>(F_SCC<T0, T1, T2> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class where T2 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0, array1[i], array2[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESCCC<T0, T1, T2, T3>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3)            where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_ESCCC<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, array1[i], array2[i], array3[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SCCC<T0, T1, T2, T3>(T0 c0, T1 c1, T2 c2, T3 c3)            where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class;

        unsafe protected void ForEach<T0, T1, T2, T3>(F_SCCC<T0, T1, T2, T3> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0, array1[i], array2[i], array3[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESCCCC<T0, T1, T2, T3, T4>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)            where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class where T4 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_ESCCCC<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class where T4 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SCCCC<T0, T1, T2, T3, T4>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4)            where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class where T4 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4>(F_SCCCC<T0, T1, T2, T3, T4> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class where T4 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0, array1[i], array2[i], array3[i], array4[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_ESCCCCC<T0, T1, T2, T3, T4, T5>(Entity entity, T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)            where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_ESCCCCC<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
            
                var entityType = GetArchetypeChunkEntityType();
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, EntityManager);
                        var entityArray = chunk.GetNativeArray(entityType);
                        for (int i = 0; i < length; ++i)
                            operate(entityArray[i], array0, array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }         
        protected delegate void F_SCCCCC<T0, T1, T2, T3, T4, T5>(T0 c0, T1 c1, T2 c2, T3 c3, T4 c4, T5 c5)            where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class;

        unsafe protected void ForEach<T0, T1, T2, T3, T4, T5>(F_SCCCCC<T0, T1, T2, T3, T4, T5> operate, ComponentGroup group = null) where T0 : struct, ISharedComponentData where T1 : class where T2 : class where T3 : class where T4 : class where T5 : class
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            EntityManager.m_InsideForEach++;
            try
#endif
            {
                if (group == null)
                {
                    group = GetCachedComponentGroup_Delegate(operate);
                    if (group == null)
                        group = CreateCachedComponentGroup_Delegate(operate, ComponentType.Create<T0>(), ComponentType.Create<T1>(), ComponentType.Create<T2>(), ComponentType.Create<T3>(), ComponentType.Create<T4>(), ComponentType.Create<T5>());
                }
                var chunkComponentType0 = GetArchetypeChunkSharedComponentType<T0>();
                var chunkComponentType1 = GetArchetypeChunkComponentType<T1>();
                var chunkComponentType2 = GetArchetypeChunkComponentType<T2>();
                var chunkComponentType3 = GetArchetypeChunkComponentType<T3>();
                var chunkComponentType4 = GetArchetypeChunkComponentType<T4>();
                var chunkComponentType5 = GetArchetypeChunkComponentType<T5>();

                using (var chunks = group.CreateArchetypeChunkArray(Allocator.TempJob))
                {
                    foreach (var chunk in chunks)
                    {
                        var length = chunk.Count;

                        var array0 = chunk.GetSharedComponentData(chunkComponentType0, EntityManager);
                        var array1 = chunk.GetComponentObjects(chunkComponentType1, EntityManager);
                        var array2 = chunk.GetComponentObjects(chunkComponentType2, EntityManager);
                        var array3 = chunk.GetComponentObjects(chunkComponentType3, EntityManager);
                        var array4 = chunk.GetComponentObjects(chunkComponentType4, EntityManager);
                        var array5 = chunk.GetComponentObjects(chunkComponentType5, EntityManager);
                        for (int i = 0; i < length; ++i)
                            operate(array0, array1[i], array2[i], array3[i], array4[i], array5[i]);
                    }
                }
            }
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            finally
            {
                EntityManager.m_InsideForEach--;
            }
#endif
        }
    }
}
