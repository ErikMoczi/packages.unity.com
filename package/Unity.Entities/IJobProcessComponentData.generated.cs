// Generated by IJobProcessComponentDataGenerator.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#if !UNITY_ZEROPLAYER

using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using UnityEngine.Scripting;
using System;


namespace Unity.Entities
{
    


        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_D<,>))]
        public interface IJobProcessComponentData<U0> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_D
            where U0 : struct, IComponentData
        {
            void Execute(ref U0 c0);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_ED<,>))]
        public interface IJobProcessComponentDataWithEntity<U0> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_ED
            where U0 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DD<,,>))]
        public interface IJobProcessComponentData<U0, U1> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDD<,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DDD<,,,>))]
        public interface IJobProcessComponentData<U0, U1, U2> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1, ref U2 c2);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDDD<,,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1, U2> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DDDD<,,,,>))]
        public interface IJobProcessComponentData<U0, U1, U2, U3> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDDDD<,,,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1, U2, U3> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DDDDD<,,,,,>))]
        public interface IJobProcessComponentData<U0, U1, U2, U3, U4> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDDDDD<,,,,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1, U2, U3, U4> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DDDDDD<,,,,,,>))]
        public interface IJobProcessComponentData<U0, U1, U2, U3, U4, U5> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4, ref U5 c5);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDDDDDD<,,,,,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1, U2, U3, U4, U5> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4, ref U5 c5);
        }

    public static partial class JobProcessComponentDataExtensions
    {
            
            public static JobHandle Schedule<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle ScheduleSingle<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle Run<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle ScheduleGroup<T>(this T jobData, ComponentGroup componentGroup, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle ScheduleGroupSingle<T>(this T jobData, ComponentGroup componentGroup, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Batched);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle RunGroup<T>(this T jobData, ComponentGroup componentGroup, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, null, componentGroup, -1, dependsOn, ScheduleMode.Run);             
                throw new System.ArgumentException("Not supported");
            }
            
            internal static unsafe JobHandle ScheduleInternal_D<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_D<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_D<,>), isParallelFor, ref JobStruct_ProcessInfer_D<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_D<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_D<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_D : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_D<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_D<T, U0>
                where T : struct, IJobProcessComponentData<U0>
            where U0 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_D<T, U0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_D<T, U0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_D<T, U0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_D<T, U0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_ED<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_ED<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_ED<,>), isParallelFor, ref JobStruct_ProcessInfer_ED<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_ED<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ED<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_ED : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_ED<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_ED<T, U0>
                where T : struct, IJobProcessComponentDataWithEntity<U0>
            where U0 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ED<T, U0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_ED<T, U0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_ED<T, U0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_ED<T, U0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DD<,,>), isParallelFor, ref JobStruct_ProcessInfer_DD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_DD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DD<T, U0, U1>
                where T : struct, IJobProcessComponentData<U0, U1>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DD<T, U0, U1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DD<T, U0, U1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DD<T, U0, U1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DD<T, U0, U1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDD<,,>), isParallelFor, ref JobStruct_ProcessInfer_EDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_EDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDD<T, U0, U1>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDD<T, U0, U1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDD<T, U0, U1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDD<T, U0, U1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDD<T, U0, U1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DDD<,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_DDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DDD<T, U0, U1, U2>
                where T : struct, IJobProcessComponentData<U0, U1, U2>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDD<T, U0, U1, U2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DDD<T, U0, U1, U2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DDD<T, U0, U1, U2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DDD<T, U0, U1, U2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDDD<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_EDDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDDD<T, U0, U1, U2>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1, U2>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDD<T, U0, U1, U2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDDD<T, U0, U1, U2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDDD<T, U0, U1, U2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDDD<T, U0, U1, U2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DDDD<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_DDDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DDDD<T, U0, U1, U2, U3>
                where T : struct, IJobProcessComponentData<U0, U1, U2, U3>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDD<T, U0, U1, U2, U3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDDDD<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_EDDDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDDDD<T, U0, U1, U2, U3>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1, U2, U3>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDD<T, U0, U1, U2, U3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DDDDD<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_DDDDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4>
                where T : struct, IJobProcessComponentData<U0, U1, U2, U3, U4>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                        var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDDDDD<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_EDDDDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1, U2, U3, U4>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                        var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DDDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DDDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DDDDDD<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDDDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_DDDDDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_DDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DDDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DDDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5>
                where T : struct, IJobProcessComponentData<U0, U1, U2, U3, U4, U5>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 
                        var typeLookupCache5 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                        var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
                        var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<U5>(ptr5, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDDDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDDDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDDDDDD<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDDDD<T>.Cache, out fullData.Iterator);
                
                var unfilteredChunkCount = fullData.Iterator.m_Length;
                var iterator = JobStruct_ProcessInfer_EDDDDDD<T>.Cache.ComponentGroup.GetComponentChunkIterator();

                var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);
                               
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EDDDDDD<T>.Cache, deferredCountData, prefilterHandle, mode);            
            }

            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDDDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDDDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1, U2, U3, U4, U5>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
                
                [DeallocateOnJobCompletion]
                [NativeDisableContainerSafetyRestriction]
                public NativeArray<byte> PrefilterData;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    var chunks = (ArchetypeChunk*)NativeArrayUnsafeUtility.GetUnsafePtr(jobData.PrefilterData);
                    var entityIndices = (int*) (chunks + jobData.Iterator.m_Length);
                    var chunkCount = *(entityIndices + jobData.Iterator.m_Length);

                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
                {
                        var typeLookupCache0 = 0; 
                        var typeLookupCache1 = 0; 
                        var typeLookupCache2 = 0; 
                        var typeLookupCache3 = 0; 
                        var typeLookupCache4 = 0; 
                        var typeLookupCache5 = 0; 

                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {    
                        var chunk = chunks[blockIndex];
                        int beginIndex = entityIndices[blockIndex];
                        var count = chunk.Count;
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
    #endif       
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
                        var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
                        ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
                        var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));
   

                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<U5>(ptr5, i));
                        }
                    }
                }
            }
        
    }
}

#endif
