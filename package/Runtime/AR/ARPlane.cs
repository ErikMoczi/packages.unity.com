using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation
{
    /// <summary>
    /// Represents a plane (i.e., a flat surface) detected by an AR device.
    /// </summary>
    /// <remarks>
    /// Generated by the <see cref="ARPlaneManager"/> when an AR device detects
    /// a plane in the environment.
    /// </remarks>
    [DisallowMultipleComponent]
    [HelpURL("https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@1.0/api/UnityEngine.XR.ARFoundation.ARPlane.html")]
    public sealed class ARPlane : ARTrackable<BoundedPlane, ARPlane> 
    {
        [SerializeField]
        [Tooltip("The largest value by which a plane's vertex may change before the boundaryChanged event is invoked. Units are in meters.")]
        float m_VertexChangedThreshold = 0.01f;

        /// <summary>
        /// The largest value by which a plane's vertex may change before the mesh is regenerated. Units are in meters.
        /// </summary>
        public float vertexChangedThreshold
        {
            get { return m_VertexChangedThreshold; }
            set { m_VertexChangedThreshold = Mathf.Max(0f, value); }
        }

        /// <summary>
        /// Invoked when any vertex in the plane's boundary changes by more than <see cref="vertexChangedThreshold"/>.
        /// </summary>
        public event Action<ARPlaneBoundaryChangedEventArgs> boundaryChanged;

        /// <summary>
        /// Gets the normal to this plane in world space.
        /// </summary>
        public Vector3 normal
        {
            get { return transform.up; }
        }

        /// <summary>
        /// The <see cref="ARPlane"/> which has subsumed this plane, or <c>null</c>
        /// if this plane has not been subsumed.
        /// </summary>
        public ARPlane subsumedBy { get; internal set; }

        /// <summary>
        /// The alignment of this plane.
        /// </summary>
        public PlaneAlignment alignment { get { return sessionRelativeData.alignment; } }

        /// <summary>
        /// The 2D center point, in plane space
        /// </summary>
        public Vector2 centerInPlaneSpace { get { return sessionRelativeData.center; } }

        /// <summary>
        /// The 3D center point, in Unity world space.
        /// </summary>
        public Vector3 center { get { return transform.TransformPoint(centerInPlaneSpace); } }

        /// <summary>
        /// The physical extents (half dimensions) of the plane in meters.
        /// </summary>
        public Vector2 extents { get { return sessionRelativeData.extents; } }

        /// <summary>
        /// The physical size (dimensions) of the plane in meters.
        /// </summary>
        public Vector2 size { get { return sessionRelativeData.size; } }

        /// <summary>
        /// Get the infinite plane associated with this <see cref="ARPlane"/>.
        /// </summary>
        public Plane infinitePlane { get { return new Plane(normal, transform.position); } }

        /// <summary>
        /// Get a native pointer associated with this plane.
        /// </summary>
        /// <remarks>
        /// The data pointed to by this member is implementation defined.
        /// The lifetime of the pointed to object is also
        /// implementation defined, but should be valid at least until the next
        /// <see cref="ARSession"/> update.
        /// </remarks>
        public IntPtr nativePtr { get { return sessionRelativeData.nativePtr; } }

        /// <summary>
        /// Copies the 2D boundary points in plane space to <paramref name="boundaryOut"/>.
        /// </summary>
        /// <param name="boundaryOut">The destination <c>List</c> whose contents are replace with the current boundary.</param>
        public void GetPlaneSpaceBoundary(List<Vector2> boundaryOut)
        {
            if (boundaryOut == null)
                throw new ArgumentNullException("boundaryOut");

            boundaryOut.Clear();
            if (m_Boundary != null)
                boundaryOut.AddRange(m_Boundary);
        }

        /// <summary>
        /// Copies the 3D boundary points in session space to <paramref name="boundaryOut"/>.
        /// </summary>
        /// <param name="boundaryOut">The destination <c>List</c> whose contents are replace with the current boundary.</param>
        public void GetSessionSpaceBoundary(List<Vector3> boundaryOut)
        {
            if (boundaryOut == null)
                throw new ArgumentNullException("boundaryOut");

            boundaryOut.Clear();
            if (m_Boundary != null)
            {
                var pose = sessionRelativeData.pose;
                foreach (var point in m_Boundary)
                    boundaryOut.Add(pose.rotation * new Vector3(point.x, 0, point.y) + pose.position);
            }
        }

        /// <summary>
        /// Copies the 3D boundary points in Unity world space to <paramref name="boundaryOut"/>.
        /// </summary>
        /// <param name="boundaryOut">The destination <c>List</c> whose contents are replace with the current boundary.</param>
        public void GetWorldSpaceBoundary(List<Vector3> boundaryOut)
        {
            if (boundaryOut == null)
                throw new ArgumentNullException("boundaryOut");

            boundaryOut.Clear();
            if (m_Boundary != null)
            {
                foreach (var point in m_Boundary)
                    boundaryOut.Add(transform.TransformPoint(new Vector3(point.x, 0, point.y)));
            }
        }

        internal void SetPlaneSpaceBoundaryPoints(NativeArray<Vector2> boundary)
        {
            if (m_Boundary == null)
                m_Boundary = new List<Vector2>();

            m_Boundary.Clear();
            foreach (var point in boundary)
                m_Boundary.Add(point);

            if (boundaryChanged != null)
                CheckForBoundaryChanges();
        }

        void OnValidate()
        {
            vertexChangedThreshold = Mathf.Max(0f, vertexChangedThreshold);
        }

        void CheckForBoundaryChanges()
        {
            if (m_OldBoundary == null)
            {
                m_OldBoundary = new List<Vector2>();
                CopyBoundaryAndSetChangedFlag();
            }
            else if (m_Boundary.Count != m_OldBoundary.Count)
            {
                CopyBoundaryAndSetChangedFlag();
            }
            else if (vertexChangedThreshold == 0f)
            {
                // Don't need to check each vertex because it will always
                // be "different" if threshold is zero.
                CopyBoundaryAndSetChangedFlag();
            }
            else
            {
                // Counts are the same; check each vertex
                var thresholdSquared = vertexChangedThreshold * vertexChangedThreshold;
                for (int i = 0; i < m_Boundary.Count; ++i)
                {
                    var diffSquared = (m_Boundary[i] - m_OldBoundary[i]).sqrMagnitude;
                    if (diffSquared > thresholdSquared)
                    {
                        CopyBoundaryAndSetChangedFlag();
                        break;
                    }
                }
            }
        }

        void CopyBoundaryAndSetChangedFlag()
        {
            // Copy new boundary
            m_OldBoundary.Clear();
            m_OldBoundary.AddRange(m_Boundary);
            m_HasBoundaryChanged = true;
        }

        void Update()
        {
            if (m_HasBoundaryChanged && (boundaryChanged != null))
            {
                m_HasBoundaryChanged = false;
                boundaryChanged(new ARPlaneBoundaryChangedEventArgs(this));
            }
        }

        List<Vector2> m_Boundary;

        List<Vector2> m_OldBoundary;

        bool m_HasBoundaryChanged;
    }
}
