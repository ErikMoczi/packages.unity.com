using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using System.IO;
using System;
using Unity.MemoryProfiler.Editor;
#if UNITY_2019_1_OR_NEWER
using UnityEngine.UIElements;
#else
using UnityEngine.Experimental.UIElements;
#endif
using UnityEditorInternal;

namespace Unity.MemoryProfiler.Editor
{
    internal class SnapshotCollectionEnumerator : IEnumerator<SnapshotFileData>
    {
        int m_Index;
        List<SnapshotFileData> m_Files;
        
        public SnapshotFileData Current { get { return m_Files[m_Index]; } }
        object IEnumerator.Current { get { return Current; } }
        public int Count { get { return m_Files.Count; } }

        internal SnapshotCollectionEnumerator(List<SnapshotFileData> files)
        {
            m_Files = files;
            Reset();
        }

        public void Dispose()
        {
            m_Files = null;
        }

        public bool MoveNext()
        {
            ++m_Index;

            return m_Index < m_Files.Count;
        }

        public void Reset()
        {
            m_Index = -1;
        }
    }

    internal enum ImportMode
    {
        Copy,
        Move
    }

    internal class SnapshotCollection
    {
        DirectoryInfo m_Info;
        List<SnapshotFileData> m_Snapshots;
        bool m_PrevApplicationFocusState;
        public Action collectionRefresh;

        public string Name { get { return m_Info.Name; } }

        public SnapshotCollection(string collectionPath)
        {
            m_Info = new DirectoryInfo(collectionPath);
            if (!m_Info.Exists)
            {
                m_Info = Directory.CreateDirectory(collectionPath);
                if (!m_Info.Exists)
                    throw new UnityException("Failed to create directory, with provided preferences path: " + collectionPath);
            }

            RefreshFileListInternal(m_Info);
            m_PrevApplicationFocusState = InternalEditorUtility.isApplicationActive;
            EditorApplication.update += PoolForApplicationFocus;
        }

        ~SnapshotCollection()
        {
            EditorApplication.update -= PoolForApplicationFocus;
        }

        void RefreshFileListInternal(DirectoryInfo info)
        {
            m_Snapshots = new List<SnapshotFileData>();
            var fileEnumerator = info.GetFiles('*' + MemoryProfilerWindow.k_SnapshotFileExtension, SearchOption.AllDirectories);
            for (int i = 0; i < fileEnumerator.Length; ++i)
            {
                FileInfo fInfo = fileEnumerator[i];
                if (fInfo.Length != 0)
                {
                    try
                    {
                        m_Snapshots.Add(new SnapshotFileData(fInfo));
                    }
                    catch(IOException e)
                    {
                        Debug.LogError("Failed to load snapshot, error: " + e.Message);
                    }
                }
            }
        }
        
        public void RenameSnapshot(SnapshotFileData snapshot, string name)
        {
            int nameStart = snapshot.FileInfo.FullName.LastIndexOf(snapshot.FileInfo.Name);
            string targetPath = snapshot.FileInfo.FullName.Substring(0, nameStart) + name + MemoryProfilerWindow.k_SnapshotFileExtension;
            snapshot.FileInfo.MoveTo(targetPath);
            snapshot.GuiData.name = new GUIContent(name);
            snapshot.GuiData.dynamicVisualElements.snapshotNameLabel.text = name;
            snapshot.GuiData.RenamingFieldVisible = false;
            m_Info.Refresh();
        }

        public void RemoveSnapshotFromCollection(SnapshotFileData snapshot)
        {
            snapshot.FileInfo.Delete();
            m_Snapshots.Remove(snapshot);
            m_Info.Refresh();
        }

        public void RemoveSnapshotFromCollection(SnapshotCollectionEnumerator iter)
        {
            RemoveSnapshotFromCollection(iter.Current);
        }

        public SnapshotFileData AddSnapshotToCollection(string path, ImportMode mode = ImportMode.Copy)
        {
            FileInfo file = new FileInfo(path);
            if (file.FullName.StartsWith(m_Info.FullName))
            {
                if(m_Snapshots.Find(item => item.FileInfo == file) == null)
                {
                    m_Snapshots.Add(new SnapshotFileData(file));
                    m_Info.Refresh();
                    return m_Snapshots[m_Snapshots.Count - 1];
                }
            }
            else
            {
                string newPath = m_Info.FullName + Path.DirectorySeparatorChar + Path.GetFileNameWithoutExtension(file.Name) + "-import-" + DateTime.Now.Ticks + MemoryProfilerWindow.k_SnapshotFileExtension;
                switch (mode)
                {
                    case ImportMode.Copy:
                        file = file.CopyTo(newPath);
                        break;
                    case ImportMode.Move:
                        file.MoveTo(newPath);
                        break;
                }
                m_Snapshots.Add(new SnapshotFileData(file));
                m_Info.Refresh();
                return m_Snapshots[m_Snapshots.Count - 1];
            }
            return null;
        }

        public void RefreshCollection()
        {
            DirectoryInfo rootDir = new DirectoryInfo(m_Info.FullName);
            if (rootDir.LastWriteTime != m_Info.LastWriteTime)
            {
                m_Info = new DirectoryInfo(m_Info.FullName);
                RefreshFileListInternal(m_Info);

                if (collectionRefresh != null)
                {
                    collectionRefresh();
                }
            }
        }

        public SnapshotCollectionEnumerator GetEnumerator()
        {
            return new SnapshotCollectionEnumerator(m_Snapshots);
        }
        
        private void PoolForApplicationFocus()
        {
            if (m_PrevApplicationFocusState != InternalEditorUtility.isApplicationActive)
            {
                if (!m_PrevApplicationFocusState)
                {
                    RefreshCollection();
                }
                m_PrevApplicationFocusState = InternalEditorUtility.isApplicationActive;
            }
        }
    }
}
